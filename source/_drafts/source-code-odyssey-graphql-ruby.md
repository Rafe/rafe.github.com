title: 'Source code odyssey: GraphQL Ruby'
date: 2021-10-21 15:59:04
tags: ruby graphql
---

Recently I am working with GraphQL on a day-to-day basis. The more I work with it, the more I like the GraphQL API compare to the traditional Restful API. And it is an interesting project, this article is going to do a deep dive on the ruby implementation of [GraphQL](https://graphql-ruby.org/) and share some discovery alone the way.

GraphQL is developed by Facebook (Now Meta), durning the development, they found a problem in Restful API that the API can not adapt to the change of client, either it fetch too much data that the client does not need, or it does not have the data it need for rendering. Therefore they have the idea to create a API specific scripting language to descripbe what API can provide, what the client want and execute to give the exactly data needed, in a declarative way, for example:

```
query {
  user(id: 1) {
    id
    name
    email

    cartItems {
      id
      name
      price
    }
  }
}
```

The GraphQL query start from a query root, and declare the data `fields` it needs from query root, in this example we query the `user` field with argument `id:1`, and after the field we can select more fields that we want to query from the return type, and it can be nested like a graph. The API provides a schema so you know what is the valid field for each types.

```
schema {
  query: QueryRoot
}

type QueryRoot {
  user(id: ID!): User
}

type User {
  id: ID!
  name: String!

  cartItems: [CartItem!]!
}

type CartItem {
  id: ID!
  name: String!
  price: Int!
}
```

This defines the types and data that the API provides. So the user can fabricate the query to fetch exactly the data they need for the client. 

So how is GraphQL query executed in the backend? It is actually similar to how interpreter run scripting language, since GraphQL is a mini scripting language ifself.
## Lifecycle

As a scripting language, the query is passed to the API by a POST request, and executed in backend in follow sequence:

1. Tokenize: `GraphQL::Language::Lexer` splits the string into a stream of tokens
2. Parse: `GraphQL::Language::Parser` builds an abstract syntax tree (AST) out of the stream of tokens
3. Validate: `GraphQL::StaticValidation::Validator` validates the incoming AST as a valid query for the schema
4. Analyze: If there are any query analyzers, they are run with `GraphQL::Analysis.analyze_query`
5. Execute: The query is traversed, `resolve` functions are called and the response is built
6. Respond: The response is returned as a Hash

## Tokenize and Parse

Like every programming language. Before we execute GraphQL query, we need to parse it to create Abstract Syntax Tree. In GraphQL-Ruby, the parser is implemented by [racc](https://github.com/ruby/racc). Which provide a syntax to generate ruby compiler to parse other language.

In GraphQL ruby, the entry point is `GraphQL.parse(query)` which invoke the `GraphQL::Language::Parser.parse`, which generated by [parser.y]("https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/language/parser.y")

```
  GraphQL.parse(query)
```

- Racc
- query AST
  - GraphQL.parse(query) => parsed into @document
    - GraphQL::Language::Parser
    - Graphql::Language::Nodes::AbstractNode
      - children, defined by children_methods
      - scalars, defined by scalar_methods
        return [Integer/Float/StringBoolean/Array] values for comparison
         meta! [@method1, @method2, @method3]
         for example: Argument#scaler = [@name, @value]
                      Field#scaler = [@name, @alias]
      - to_query_string => print ast
    - Graphql::Language::Nodes::Argument
    - Graphql::Language::Nodes::Field
      - children_methods({
          arguments: GraphQL::Language::Node::Argument
          selections: GraphQL::Language::Nodes::Field
          directives: GraphQL::Language::Nodes::Directive
        })
        - add a reader for there children
          - .arguments
          - .selections
        - add a update method to add a child
          - def merge_arguments ...
          - def merge_selection ...
          - def merge_directives(params) ...
            - merge(directives: directives + [GraphQL::Language::Nodes::Directive.new(params)])
        - generate a #children method
          - all subtypes joins
    - Graphql::Language::Nodes::Directive
    - Graphql::Language::Nodes::Document
    - Graphql::Language::Nodes::FragmentDefinition
      - fragment definitions
    - Graphql::Language::Nodes::OperationDefinition
      - query, mutation or subscription
    - Graphql::Language::SchemaDefinition
- mutation
- field

Directives? => @skip and @include annotation
  - implement feature flag https://graphql-ruby.org/api-doc/1.12.16/GraphQL/Schema/Directive/Feature
  - implement upcase transform
## Validate and Analyze

Validate: GraphQL::StaticValidation::Validator validates the incoming AST as a valid query for the schema
  - GraphQL::StaticValidation::ALL_RULES is the visitor rules
  - GraphQL::Language::Visitor - Depth first traversal visitor
    - make_visitor_methods
    - on_abstract_node is the main visit method
## Schema and Types

- schema object
  - types for exposing your application
  - query analyzers for assessing incoming queries ( max depth & max complexity )
  - execution strategies (single/multiplex)
  - root types
    - query
    - mutation
    - subscription
  - after types added => add_type_and_traverse
  - schema.types
  - query stragegy
    - query_execution_strategy
    - mutation_execution_strategy
    - subscription_execution_strategy

  - schema object
    - collection of GraphQL Types
    - to_graphql => GraphQL::ObjectType
    - name
    - description
    - context
    - object -> wrapping an application object
      - dataloader?
      - have an object and context
        - take object and context to initialize
      - implements => specify interface
      - fields
        - HasFields
          - def field
          - field_class.from_options
          - field_class = GraphQL::Schema::Field

Introspection: output the structure of the schema and __typename as GDL

## Execute

- entry point: Graphql::Execution::Interpreter

- irep_nodes
- new intepreter to avoid irep_nodes and consume AST directly

GraphQL::Execution::Multiplex.run_all

GraphQL::Execution::Execute.use(schema_class)
GraphQL::Execution::Execute.execute(ast, root_type, query)

GraphQL::Query object:
  schema, query string, query, context, variables
  GraphQL::Tracing::Traceable => can trace with tracer, stack tracers
    inherit tracers from schema and context:
      @tracers = schema.tracers + (context ? context.fetch(:tracers, []) : [])

"selection" concept => equals to Field
"selected_operation"