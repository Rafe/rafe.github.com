<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: coffee-script | Neethack]]></title>
  <link href="http://neethack.com/categories/coffee-script/atom.xml" rel="self"/>
  <link href="http://neethack.com/"/>
  <updated>2013-04-23T00:47:20-04:00</updated>
  <id>http://neethack.com/</id>
  <author>
    <name><![CDATA[Jimmy Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Minispec : mini BDD framework in coffeescript]]></title>
    <link href="http://neethack.com/2012/11/minispec-mini-bdd-framework-in-coffeescript/"/>
    <updated>2012-11-07T15:16:00-05:00</updated>
    <id>http://neethack.com/2012/11/minispec-mini-bdd-framework-in-coffeescript</id>
    <content type="html"><![CDATA[<h2>Just another test framework</h2>

<p>During the catastrophe of Sandy storm, my place have no electricity and water, so I stay in my friends place for whole week.
And I need to find something to do except eating, surfing internet and boardgame.
So I just wrote another test framework.</p>

<p>Inspired by Zach Holoman's <a href="https://gist.github.com/1806986">gist</a>
I try to host the framework in the gist form. Because every gist is also a git repository.</p>

<p><a href="https://gist.github.com/4033566">gist source</a></p>

<!-- more -->


<h2>Spec</h2>

<p>The README.md file is also a runnable spec in coffeescript.
run</p>

<pre><code>npm test
</code></pre>

<p>in project can execute the spec</p>

<p><div><script src='https://gist.github.com/4033566.js?file=README.md'></script>
<noscript><pre><code># Minispec
#### minispec is a mini bdd test framework example
    # npm install git://gist.github.com/4033566.git

    # require('minispec') in your project
    require('./minispec')

    # use expect.js for assertion (http://n37.co/aemDq)
    expect = require('expect.js')

    user = &quot;&quot;
    describe &quot;Minispec&quot;, -&gt;
      before -&gt;
        user = name: &quot;Jimmy&quot;

      it 'can success', -&gt;
        expect(true).to.be.ok()

      it 'can fail', -&gt;
        expect().fail -&gt;

      it 'have before', -&gt;
        expect(user.name).to.equal &quot;Jimmy&quot;

      describe 'after', -&gt;

        after -&gt;
          throw new Error('in after')

        it 'will be executed', -&gt;
          expect(true).to.be.ok()

      describe 'nested describe', -&gt;
        before -&gt;
          user.password = '123'

        it 'with nested before', -&gt;
          expect(user.password).to.be '123'

        it 'with nested after', -&gt;
          expect(user.password).to.be '123'

        it 'can also have error', -&gt;
          expect().fail -&gt;

        describe 'nested in nested', -&gt;
          it 'is nested', -&gt;
            expect(1).to.be.ok()

      describe 'async function', -&gt;

        it 'have callback', (done)-&gt;
          expect(1).to.be.ok()
          done()
</code></pre></noscript></div>
</p>

<h2>Global delegation</h2>

<p>One of the problem is the format of syntax.
Because I want to write syntax without extra <code>this</code> keyword, so instead of calling the test block with 'call',
I have to declare test syntax globally.</p>

<pre><code>#Instead this
describe = (title, block)-&gt;
  @it = (desc, fn)-&gt;
    #add test to test suite
  block.call(@)

describe "syntax", -&gt;
  @it "have this keyword", -&gt;

#Got to do it Globally
global.it = (desc, fn)-&gt;
  #add test to test suite
describe = (title, block)-&gt;
  block()

describe "syntax", -&gt;
  it "have no this keyword", -&gt;
</code></pre>

<p>But there's 2 problem of declaring global, one is the confrontation of global keywords, which is a tradeoff for simpler syntax.
Another problem is when implementing nested block, test need to be delegated into right suite.
Using a stack to track the current suite can solve this problem.</p>

<pre><code>suites = []
global.it = (desc, fn)-&gt; 
  suites[0].tests.push title: desc, fn: fn

describe = (title, block)-&gt;
  suite = new Suite(title)
  suites.unshift(suite)
  block()
  suites.shift()
</code></pre>

<p>So the global <code>it</code> will always add test to the top of stack, which is the current test suite.</p>

<h2>Hook and run</h2>

<p>For the before/after function, I use the EventEmitter to trigger the hooks, and delegate event to the parent suite:</p>

<pre><code>class Suite extends EventEmitter
  constructor: (@title, @parent)-&gt;
    ...
    @delegate ['before', 'after']
    @on 'result', @reportResult
    @on 'end', @reportSummary

  delegate: (events)-&gt;
    events.forEach (event)=&gt;
      @on event, =&gt; @parent?.emit event

  run: -&gt;
    @emit 'start'
    @tests.forEach (test)-&gt;
      try
        @emit 'before'
        test.fn()
        @emit 'result', test
        @emit 'after'
      catch err
        @emit 'result', test, err
    @emit 'end'
</code></pre>

<h2>Async</h2>

<p>For testing the async callback, <code>it</code> also provide a done callback for the async function.
And I use <a href="https://github.com/caolan/async">async</a> module to handle the test execution sequence.
It will detect the function param, if there is a specific callback param in function, execute in async mode.</p>

<h2>Source</h2>

<p><div><script src='https://gist.github.com/4033566.js?file=minispec.coffee'></script>
<noscript><pre><code>{EventEmitter} = require 'events'
async = require 'async'

#utils
color = (code)-&gt; (text = &quot;&quot;)-&gt; code + text + '\u001b[0m'
red = color('\u001b[31m')
green = color('\u001b[32m')
yellow = color('\u001b[33m')
pluralize = (count, noun)-&gt; if count &gt; 1 then noun + 's' else noun
indent = (level)-&gt; ('  ' for i in [0...level]).join('')

class Suite extends EventEmitter
  constructor: (@title, @parent)-&gt;
    @errors = 0
    @tests = []
    @childs = []
    @parent?.childs.push @
    @level = @parent?.level + 1 or 0

    @on 'start', =&gt; @report yellow @title
    @delegate ['before', 'after'] if @parent?
    @on 'result', (test, err)=&gt;
      if err?
        @errors += 1
        @report red &quot;  ✗ #{test.title} (#{err})&quot;
      else
        @report green &quot;  ✓ #{test.title}&quot;
    @on 'end', =&gt;
      count = @tests.length
      errors = @errors

      (reduce = (suites)-&gt;
        suites.forEach (suite)-&gt;
          count += suite.tests.length
          errors += suite.errors
          reduce suite.childs if suite.childs?
      )(@childs)

      console.log yellow &quot;run #{count} #{pluralize(count, 'test') } , #{count - errors} success, #{errors} failed&quot;

  delegate: (events)-&gt;
    events.forEach (event)=&gt;
      @on event, ()=&gt; @parent?.emit event

  report: (text)-&gt; console.log indent(@level) + text

  run: -&gt;
    @emit 'start'
    async.forEachSeries @tests, (test, next)=&gt;
      callback = =&gt;
        @emit('after')
        @emit('result', test)
        next()

      try
        @emit('before')
        if test.isAsync
          test.fn callback
        else
          test.fn()
          callback()
      catch err
        @emit('result', test, err)
        next()
    , =&gt;
      @childs.forEach (spec)-&gt; spec.run()
      @emit 'end' unless @parent?

class Runner
  constructor: (context)-&gt;
    suites = []
    context.it = (desc, fn)-&gt;
      suites[0].tests.push title: desc, fn: fn, isAsync: !!fn.length
    context.before = (fn)-&gt;
      suites[0].on 'before', fn
    context.after = (fn)-&gt;
      suites[0].on 'after', fn
    context.describe = (title, block)-&gt;
      suite = new Suite(title, suites[0])
      suites.unshift(suite)
      block()
      suites.shift()
      suite.run() if suites.length is 0

new Runner(global or window)
</code></pre></noscript></div>
</p>

<h2>Summary</h2>

<p>Credit to VisionMedia's <a href="https://github.com/visionmedia/mocha">mocha</a> framework, lots of solution is comming from there.</p>

<p>But still this is an intersting small project to do in the storm days.</p>

<p>And I am so happy to back to the normal life.</p>
]]></content>
  </entry>
  
</feed>
