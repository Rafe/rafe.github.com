<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Source code odyssey: GraphQL Ruby | Neethack</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Neethack">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head" >
    <div class="vertical">
        <div class="site-head-content inner">
            
            <h1 class="blog-title"><a href="http://neethack.com">Neethack</a></h1>
            <h2 class="blog-description"></h2>
        </div>
    </div>
</header>

  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2021-11-18T05:00:00.000Z" itemprop="datePublished">
          2021-11-18
      </time>
    
    
    | 
    <a href='/tags/ruby-graphql/'>ruby graphql</a>
    
    
</span>
    <h1 class="post-title">Source code odyssey: GraphQL Ruby</h1>
    <section class="post-content">
      <p><img src="top.png" alt="cover image"></p>
<p>Recently I am working with GraphQL on a day-to-day basis. The more I work with it, the more I like the GraphQL API compared to the traditional Restful API. And it is an interesting project, this article is going to do a deep dive on the ruby implementation of <a href="https://graphql-ruby.org/" target="_blank" rel="noopener">GraphQL</a> and share some discoveries along the way.</p>
<p>GraphQL is developed by Facebook (Now Meta), during the development of the new version of Facebook, they found a problem in Restful API that the API can not adapt to the rapid change of client, either it fetches too much data that the client does not need, or it does not have the data it needs for rendering. Therefore they have the idea to create an API specific scripting language to describe what API can provide, what the client wants and execute to give the exact data the client needed in a declarative way, for example:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(<span class="built_in">id</span>: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">id</span></span><br><span class="line">    <span class="built_in">name</span></span><br><span class="line">    email</span><br><span class="line"></span><br><span class="line">    cartItems &#123;</span><br><span class="line">      <span class="built_in">id</span></span><br><span class="line">      <span class="built_in">name</span></span><br><span class="line">      price</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The GraphQL query start from a query root, and declare the data <code>fields</code> it needs from query root, in this example we query the <code>user</code> field with argument <code>id:1</code>, and after the field we can select more fields that we want to query from the return type, and it can be nested like a graph. The API provides a schema so you know what is the valid fields for each types.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: QueryRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QueryRoot &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line"></span><br><span class="line">  cartItems: [CartItem!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CartItem &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  price: Int!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This defines the types and data that the API provides. So the user can fabricate the query to fetch exactly the data they need for the client. </p>
<p>So how is the GraphQL query executed in the backend? It is similar to how interpreters run scripting language since GraphQL is a mini scripting language itself.</p>
<h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>As a scripting language, the query is passed to the API by a POST request, and executed in the backend in following sequence:</p>
<ol>
<li>Tokenize: <code>GraphQL::Language::Lexer</code> splits the string into a stream of tokens</li>
<li>Parse: <code>GraphQL::Language::Parser</code> builds an abstract syntax tree (AST) out of the stream of tokens</li>
<li>Validate: <code>GraphQL::StaticValidation::Validator</code> validates the incoming AST as a valid query for the schema</li>
<li>Analyze: If there are any query analyzers, they are run with <code>GraphQL::Analysis.analyze_query</code></li>
<li>Execute: The query is traversed, <code>resolve</code> functions are called and the response is built</li>
<li>Respond: The response is returned as a Hash</li>
</ol>
<h2 id="Tokenize-and-Parse"><a href="#Tokenize-and-Parse" class="headerlink" title="Tokenize and Parse"></a>Tokenize and Parse</h2><p>Like every programming language. Before we execute the GraphQL query, we need to parse it to create an Abstract Syntax Tree. In GraphQL-Ruby, the parser is implemented by <a href="https://github.com/ruby/racc" target="_blank" rel="noopener">racc</a>. Which provides a syntax to generate Ruby compiler to parse another language.</p>
<p>In GraphQL ruby, the entry point is <code>GraphQL.parse(query)</code> which invoke the <code>GraphQL::Language::Parser.parse</code>, which generated by <a href="&quot;https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/language/parser.y&quot;">parser.y</a></p>
<p><code>parser.y</code> define the GraphQL grammer rules, tokenize the query by <code>GraphQL::Language::Lexer.tokenize(graphql_string)</code> and implement <code>make_node</code> method to create AST:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_node</span><span class="params">(node_name, assigns)</span></span></span><br><span class="line">  assigns.each <span class="keyword">do</span> <span class="params">|key, value|</span></span><br><span class="line">    <span class="keyword">if</span> key != <span class="symbol">:position_source</span> &amp;&amp; value.is_a?(GraphQL::Language::Token)</span><br><span class="line">      assigns[key] = value.to_s</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  assigns[<span class="symbol">:filename</span>] = @filename</span><br><span class="line"></span><br><span class="line">  GraphQL::Language::Nodes.const_get(node_name).new(assigns)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This method is the main action to execute in the parser, which creates nodes and Abstract Syntax Tree by <code>node_name</code>. <code>node_name</code> is defined in the rule, includes <code>Field</code>, <code>OperationDefinition</code>, <code>TypeName</code>, <code>Argument</code>, etc… For example, from the query in the example we can create the AST like this:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span> GraphQL.parse(query)</span><br><span class="line">=&gt; <span class="comment"># &lt;GraphQL::Language::Nodes::Document:0x00007fcd9c4dea10</span></span><br><span class="line"> @definitions=</span><br><span class="line">  [#&lt;GraphQL::Language::Nodes::OperationDefinition:0x00007fcd9c4deb28</span><br><span class="line">    @operation_type="query",</span><br><span class="line">    @selections=</span><br><span class="line">     [#&lt;GraphQL::Language::Nodes::Field:0x00007fcd9c4dec68</span><br><span class="line">       @arguments=</span><br><span class="line">        [#&lt;GraphQL::Language::Nodes::Argument:0x00007fcd9c4df870</span><br><span class="line">          @name="id",</span><br><span class="line">          @value=1&gt;],</span><br><span class="line">       @name=<span class="string">"user"</span>,</span><br><span class="line">       @selections=</span><br><span class="line">        [#&lt;GraphQL::Language::Nodes::Field:0x00007fcd9c4df690</span><br><span class="line">          @arguments=[],</span><br><span class="line">          @directives=[],</span><br><span class="line">          @name="id",</span><br><span class="line">          @selections=[]&gt;,</span><br><span class="line">         ...,</span><br><span class="line">         <span class="comment">#&lt;GraphQL::Language::Nodes::Field:0x00007fcd9c4deda8</span></span><br><span class="line">          @arguments=[],</span><br><span class="line">          @directives=[],</span><br><span class="line">          @name=<span class="string">"cartItems"</span>,</span><br><span class="line">          @selections=</span><br><span class="line">           [...,</span><br><span class="line">            <span class="comment">#&lt;GraphQL::Language::Nodes::Field:0x00007fcd9c4deee8</span></span><br><span class="line">             @arguments=[],</span><br><span class="line">             @directives=[],</span><br><span class="line">             @name=<span class="string">"price"</span>,</span><br><span class="line">             @selections=[]&gt;]&gt;]&gt;],</span><br><span class="line">    @variables=[]&gt;],</span><br><span class="line"> &gt;</span><br></pre></td></tr></table></figure>
<p>From the output we can see the basic layout of the AST, each node has a set of <code>children_methods</code> that differ by type of nodes. For <code>Field</code>, it is <code>arguments</code>, <code>name</code>, <code>directives</code>, and <code>selections</code>, and can call <code>Field#children</code> to retrieve them for recursion. Also, the node has a <code>#scalar_methods</code> method for comparison and <code>#merge</code> for manipulating nodes. </p>
<p>For more details about programming language in general, includes Tokenize and Parsing. I suggest the ebook: <a href="http://createyourproglang.com/" target="_blank" rel="noopener">create your programming language</a> or the <a href="https://github.com/kanaka/mal" target="_blank" rel="noopener">MAL</a> project.</p>
<h2 id="Validate-and-Analyze"><a href="#Validate-and-Analyze" class="headerlink" title="Validate and Analyze"></a>Validate and Analyze</h2><p>After we have the AST and save it in the <code>GraphQL::Query</code> object, the next step is to validate the AST is valid for the schema, and analyze the complexity and information of the AST.</p>
<p>We call <code>GraphQL::StaticValidation::Validator#validate</code> with the Query object, and call the visitor <code>GraphQL::StaticValidation::BaseVisitor</code> which is a depth-first traversal visitor that include the rules in <code>GraphQL::StaticValidation::ALL_RULES</code> that defines all validation rules like: <code>FieldsAreDefinedOnType</code>, <code>FragmentNamesAreUnique</code>. The visitor will traverse the AST, when it visits a node, it will run the corresponding method like <code>on_field</code>, <code>on_argument</code> that is defined in rules, and return the Query is valid or not in the end.</p>
<p>After validation, we run the <code>query_analyzer</code> defined in the Schema and use the <code>GraphQL::Analysis::AST::Visitor</code> to analyze the query AST. Basically, it works similar to <code>GraphQL::StaticValidation::BaseVisitor</code> but it can carry analyzers and call the analyzer methods when visiting nodes. For example, the <code>QueryDepth</code> analyzer looks like this:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryDepth</span> &lt; Analyzer</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(query)</span></span></span><br><span class="line">    @max_depth = <span class="number">0</span></span><br><span class="line">    @current_depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">super</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">on_enter_field</span><span class="params">(node, parent, visitor)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> visitor.skipping? <span class="params">||</span> visitor.visiting_fragment_definition?</span><br><span class="line"></span><br><span class="line">    @current_depth += <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">on_leave_field</span><span class="params">(node, parent, visitor)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> visitor.skipping? <span class="params">||</span> visitor.visiting_fragment_definition?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @max_depth &lt; @current_depth</span><br><span class="line">      @max_depth = @current_depth</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    @current_depth -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">result</span></span></span><br><span class="line">    @max_depth</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Which is called by <code>GraphQL::Analysis::AST.analyze_query</code> to return the results. By default it only records errors, but we can extend the analyzer to log the result.</p>
<h2 id="Schema-and-Types"><a href="#Schema-and-Types" class="headerlink" title="Schema and Types"></a>Schema and Types</h2><p>After analyzing the query, we can start executing the query on the schema we defined. But before that, we need to explain how the schema is defined in the graphql-ruby gem. There are 3 main classes in the schema: <code>GraphQL::Schema</code>, <code>GraphQL::Schema::Object</code> and <code>GraphQL::Schema::Field</code>. </p>
<p><code>GraphQL::Schema</code> is the root of the schema, it provides an interface to execute the query, contains the root types for exposing the application, query analyzers, and execution strategies. There are 3 root types for <code>query</code>, <code>mutation</code>, and <code>subscription</code> queries.</p>
<p>The type is a <code>GraphQL::Schema::Object</code> class that contains <code>GraphQL::Schema::Field</code> that describes the interface for selecting the data, like field name, data type, arguments, and also contain <code>resolve_proc</code> or <code>resolver</code> that holds the logic for how to resolve the field.</p>
<p>From the initialize method of <code>GraphQL::Schema::Object</code>:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(object, context)</span></span></span><br><span class="line">  @object = object</span><br><span class="line">  @context = context</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>A type object instance has an inner object, the type acts like a proxy. When resolving the field, it will first check if the field has a resolver, then check the type has the method same as the field name defined, if not, then delegate the call to the inner object, if the inner object is hash, use hash fetch method instead.</p>
<p>The object value is the result of the parent field call, or for the root type like <code>query</code> or <code>mutation</code>, it is specified as <code>root_value</code> and passed when executing the query.</p>
<p>The schema for the example above looks like this:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySchema</span> &lt; GraphQL::Schema</span></span><br><span class="line">  query QueryRoot</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueryRoot</span> &lt; GraphQL::Schema::<span class="title">Object</span></span></span><br><span class="line">  field <span class="symbol">:user</span>, UserType, <span class="symbol">null:</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    argument <span class="symbol">:id</span>, ID, <span class="symbol">required:</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># read the root_value and return matched user</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(<span class="symbol">id:</span>)</span></span></span><br><span class="line">    object.find &#123; <span class="params">|u|</span> u[<span class="symbol">:id</span>] == id &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserType</span> &lt; GraphQL::Schema::<span class="title">Object</span></span></span><br><span class="line">  field <span class="symbol">:id</span>, ID, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  field <span class="symbol">:name</span>, String, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  field <span class="symbol">:email</span>, String, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  field <span class="symbol">:cartItems</span>, [CartItemType], <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemType</span> &lt; CartItemType</span></span><br><span class="line">  field <span class="symbol">:id</span>, ID, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  field <span class="symbol">:name</span>, String, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line">  field <span class="symbol">:price</span>, Int, <span class="symbol">null:</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">users = [&#123;</span><br><span class="line">  <span class="symbol">id:</span> <span class="string">"1"</span>,</span><br><span class="line">  <span class="symbol">name:</span> <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="symbol">email:</span> <span class="string">"jd@example.com"</span>,</span><br><span class="line">  <span class="symbol">cartItems:</span> [&#123;</span><br><span class="line">    <span class="symbol">id:</span> <span class="string">"2"</span>,</span><br><span class="line">    <span class="symbol">name:</span> <span class="string">"Pragmatic graphQL - edition 2"</span>,</span><br><span class="line">    <span class="symbol">price:</span> <span class="number">60</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">MySchema.execute(query, &#123;</span><br><span class="line">  <span class="symbol">context:</span> &#123;&#125;,</span><br><span class="line">  <span class="symbol">root_value:</span> users</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># =&gt; get the values defined in the example query</span></span><br></pre></td></tr></table></figure>
<p>Each type of object has an attribute called <code>own_fields</code>. When we declare <code>field :name, String, null: false</code> in type, we add a field instance with the options to the class. The field store the type information and how to resolve the query selection from type. We can get the field instance by <code>get_field</code> method.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; User.fields</span><br><span class="line">=&gt; <span class="comment"># &#123;"id"=&gt; #&lt;GraphQL::Schema::Field ...&gt;, "name"=&gt; ...&#125;</span></span><br><span class="line">&gt; User.get_field(<span class="string">"name"</span>)</span><br><span class="line">=&gt; <span class="comment"># &lt;GraphQL::Schema::Field ...&gt;</span></span><br></pre></td></tr></table></figure>
<p>And you can resolve the field by calling the <code>#resolve</code> method on field</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; context = OpenStruct.new(&#123; <span class="symbol">schema:</span> MySchema &#125;)</span><br><span class="line">&gt; user = User.send(<span class="symbol">:new</span>, users.first, context) <span class="comment"># skip authorized?</span></span><br><span class="line">&gt; field = User.get_field(<span class="string">"name"</span>)</span><br><span class="line">&gt; field.resolve(user, &#123;&#125;, context)</span><br><span class="line">=&gt; <span class="string">"John Doe"</span></span><br></pre></td></tr></table></figure>
<p>The <code>resolve</code> method will find any resolver class or proc then check the method with field name on type, and fallback to object. If the object is a hash, it will use the field name as a key instead. A simplified version looks like this:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolve</span><span class="params">(object, args, ctx)</span></span></span><br><span class="line">  application_object = object.object</span><br><span class="line">  Schmea::Validator.validate!(validators, application_object, ctx, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># check if the field is authorized</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">self</span>.authorized?(application_object, args, ctx)</span><br><span class="line">    public_send_field(object, args, ctx)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">public_send_field</span><span class="params">(object, args, ctx)</span></span></span><br><span class="line">  <span class="keyword">if</span> @resolver_class</span><br><span class="line">    object = @resolver_class.new(<span class="symbol">object:</span> object, <span class="symbol">context:</span> ctx, <span class="symbol">field:</span> <span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> object.respond_to?(@method_name)</span><br><span class="line">    object.public_send(@method_name, **args)</span><br><span class="line">  <span class="keyword">elsif</span> object.object.is_a?(Hash)</span><br><span class="line">    object.object[@method_name]</span><br><span class="line">  <span class="keyword">elsif</span> object.object.respond_to?(@method_name)</span><br><span class="line">    object.object.public_send(@method_name, **args)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">"..."</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>After we understand the structure of schema and query AST, the execute part should just match those 2 together… which I would like to say but it is actually much more complicated than this. Part of this is because there are a lot of cases and features that need to be handled, like multiplex, directives, fragments… etc, but also I wouldn’t say the algorithm is optimized in the execution logic.</p>
<p>From the entry point: <code>GraphQL::Schema.execute</code>, it will trigger the <code>query_execution_strategy</code>, which is <code>GraphQL::Execution::Interpreter</code> for GraphQL 2.0.</p>
<p>From here, we call <code>GraphQL::Execution::Interpreter#evaluate</code>, it calls  <code>GraphQL::Execution::Interpreter::Runtime#run_eager</code>, which is the actual class that execute query.</p>
<p>First, we fetch the root operation type (query, mutation, subscription) and root type, and initialize root type by calling the <code>authorized_new</code> method which calls <code>#authorized?</code> method on type to make sure the object is accessible.</p>
<p>After the params and type is set, it gathers the root selections from the query, and resolve the directives by calling <code>resolve_with_directives</code>, then gather selections, evaluates the selections by <code>evaluate_selection_with_args</code>, It gets the field definition from type, call <code>field#resolve</code> with arguments. After the field is resolved, if the result values, then set the result, else continue on the return type and pass the next selections fields on result for iterate. It resolves query as depth search first and merges the result of the fields to GraphQL result. </p>
<p>With the simplified version, it looks like this (not runnable code, just extract details from <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/execution/interpreter/runtime.rb" target="_blank" rel="noopener">source</a>) to demonstrate how the execution run:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphQL::Execution::Interpreter::Runtime</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run_eager</span></span></span><br><span class="line">    <span class="comment"># retrieve query root intormation</span></span><br><span class="line">    root_operation = query.selected_operation</span><br><span class="line">    root_op_type = root_operation.operation_type <span class="params">||</span> <span class="string">"query"</span></span><br><span class="line">    root_type = schema.root_type_for_operation(root_op_type)</span><br><span class="line"></span><br><span class="line">    selection_response = GraphQLResultHash.new(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># create instance of type object, the #authorized_new method checks</span></span><br><span class="line">    <span class="comment"># the authorized? method before initialize object</span></span><br><span class="line">    object = authorized_new(root_type, query.root_value, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gather selections from query</span></span><br><span class="line">    gathered_selections = gather_selections(object, root_type, root_operation.selections)</span><br><span class="line"></span><br><span class="line">    evaluate_selections(context.scoped_context, object, root_type, gathered_selections, selection_response)</span><br><span class="line"></span><br><span class="line">    selection_response</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate_selections</span><span class="params">(scoped_context, owner_object, owner_type, gathered_selections, results)</span></span></span><br><span class="line">    gathered_selections.each <span class="keyword">do</span> <span class="params">|selection, ast_node|</span></span><br><span class="line">      <span class="comment"># collect field informations from query ast</span></span><br><span class="line">      field_name = ast_node.name</span><br><span class="line">      field = owner_type.get_field(field_name)</span><br><span class="line">      return_type = field.type</span><br><span class="line"></span><br><span class="line">      <span class="comment"># load arguments from query</span></span><br><span class="line">      @query.arguments_cache.dataload_for(ast_node, field, object) <span class="keyword">do</span> <span class="params">|resolved_arguments|</span></span><br><span class="line">        <span class="comment"># collect field information for next selections</span></span><br><span class="line">        return_type = field.type</span><br><span class="line">        next_selections = ast_node.selections</span><br><span class="line">        directives = ast_node.directives</span><br><span class="line"></span><br><span class="line">        field_result = resolve_with_directives(object, directives) <span class="keyword">do</span></span><br><span class="line">          field.resolve(object, arguments, context)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment"># handle nested selections</span></span><br><span class="line">        continue_field(owner_type, field_result, field, return_type, next_selections, object, selection, results)</span><br><span class="line"></span><br><span class="line">        set_result(results, field_name, field_result)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">continue_field</span><span class="params">(owner_type, value, field, current_type, next_selections, owner_object, arguments, selection, results)</span></span></span><br><span class="line">    <span class="comment"># if return type is not graphql type, set result and return, else continue on selections</span></span><br><span class="line">    <span class="keyword">case</span> current_type.kind.name</span><br><span class="line">    <span class="keyword">when</span> <span class="string">"SCALAR"</span>, <span class="string">"ENUM"</span></span><br><span class="line">      set_result(results, selection, value)</span><br><span class="line">    <span class="keyword">when</span> <span class="string">"OBJECT"</span></span><br><span class="line">      object = authorized_new(current_type, value, context)</span><br><span class="line">      gathered_selections = gather_selections(value, current_type, next_selections)</span><br><span class="line">      this_result = GraphQLResultHash.new(selection, results)</span><br><span class="line">      evaluate_selections(context.scoped_context, object, current_type, gathered_selections, this_result)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Afterward, the query response will be sent to the client and end the lifecycle.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Hope this step by steps introduction can help you understand how GraphQL works underhood in general. Creating a DSL for API is a pretty complicated and aggressive idea. But Facebook executes it pretty well and I think more and more GraphQL API will come out and might become the de-facto standard of Web API, just like React. I think we can learn from this and try to find more problems that can be solved by an elegant DSL.</p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Jimchao</h4>
    <p>A developer, hacker, traveler and boarder live in New York City. You can follow my code at  <a href="http://github.com/rafe">Github</a></p>
</section>

      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://neethack.com/2021/11/source-code-odyssey-graphql-ruby/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://neethack.com/2021/11/source-code-odyssey-graphql-ruby/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://neethack.com/2021/11/source-code-odyssey-graphql-ruby/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2021/01/react-suspense-and-error-boundary/">
        React Suspense and Error Boundary →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Neethack</a> &copy; 2015 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>



<script type="text/javascript">
    var disqus_shortname = 'neethack';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>




</body>
</html>
