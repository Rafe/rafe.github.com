<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: coffee-script | Neethack]]></title>
  <link href="http://neethack.com/categories/coffee-script/atom.xml" rel="self"/>
  <link href="http://neethack.com/"/>
  <updated>2013-09-03T00:42:05-04:00</updated>
  <id>http://neethack.com/</id>
  <author>
    <name><![CDATA[Jimmy Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Minispec : mini BDD framework in coffeescript]]></title>
    <link href="http://neethack.com/2012/11/minispec-mini-bdd-framework-in-coffeescript/"/>
    <updated>2012-11-07T15:16:00-05:00</updated>
    <id>http://neethack.com/2012/11/minispec-mini-bdd-framework-in-coffeescript</id>
    <content type="html"><![CDATA[<h2>Just another test framework</h2>

<p>During the catastrophe of Sandy storm, my place have no electricity and water, so I stay in my friends place for whole week.
And I need to find something to do except eating, surfing internet and boardgame.
So I just wrote another test framework.</p>

<p>Inspired by Zach Holoman&rsquo;s <a href="https://gist.github.com/1806986">gist</a>
I try to host the framework in the gist form. Because every gist is also a git repository.</p>

<p><a href="https://gist.github.com/4033566">gist source</a></p>

<!-- more -->


<h2>Spec</h2>

<p>The README.md file is also a runnable spec in coffeescript.
run</p>

<pre><code>npm test
</code></pre>

<p>in project can execute the spec</p>

<p><div><script src='https://gist.github.com/4033566.js?file=README.md'></script>
<noscript><pre><code># Minispec
#### minispec is a mini bdd test framework example
    # npm install git://gist.github.com/4033566.git

    # require(&#39;minispec&#39;) in your project
    require(&#39;./minispec&#39;)

    # use expect.js for assertion (http://n37.co/aemDq)
    expect = require(&#39;expect.js&#39;)

    user = &quot;&quot;
    describe &quot;Minispec&quot;, -&gt;
      before -&gt;
        user = name: &quot;Jimmy&quot;

      it &#39;can success&#39;, -&gt;
        expect(true).to.be.ok()

      it &#39;can fail&#39;, -&gt;
        expect().fail -&gt;

      it &#39;have before&#39;, -&gt;
        expect(user.name).to.equal &quot;Jimmy&quot;

      describe &#39;after&#39;, -&gt;

        after -&gt;
          throw new Error(&#39;in after&#39;)

        it &#39;will be executed&#39;, -&gt;
          expect(true).to.be.ok()

      describe &#39;nested describe&#39;, -&gt;
        before -&gt;
          user.password = &#39;123&#39;

        it &#39;with nested before&#39;, -&gt;
          expect(user.password).to.be &#39;123&#39;

        it &#39;with nested after&#39;, -&gt;
          expect(user.password).to.be &#39;123&#39;

        it &#39;can also have error&#39;, -&gt;
          expect().fail -&gt;

        describe &#39;nested in nested&#39;, -&gt;
          it &#39;is nested&#39;, -&gt;
            expect(1).to.be.ok()

      describe &#39;async function&#39;, -&gt;

        it &#39;have callback&#39;, (done)-&gt;
          expect(1).to.be.ok()
          done()
</code></pre></noscript></div>
</p>

<h2>Global delegation</h2>

<p>One of the problem is the format of syntax.
Because I want to write syntax without extra <code>this</code> keyword, so instead of calling the test block with &lsquo;call&rsquo;,
I have to declare test syntax globally.</p>

<pre><code>#Instead this
describe = (title, block)-&gt;
  @it = (desc, fn)-&gt;
    #add test to test suite
  block.call(@)

describe "syntax", -&gt;
  @it "have this keyword", -&gt;

#Got to do it Globally
global.it = (desc, fn)-&gt;
  #add test to test suite
describe = (title, block)-&gt;
  block()

describe "syntax", -&gt;
  it "have no this keyword", -&gt;
</code></pre>

<p>But there&rsquo;s 2 problem of declaring global, one is the confrontation of global keywords, which is a tradeoff for simpler syntax.
Another problem is when implementing nested block, test need to be delegated into right suite.
Using a stack to track the current suite can solve this problem.</p>

<pre><code>suites = []
global.it = (desc, fn)-&gt; 
  suites[0].tests.push title: desc, fn: fn

describe = (title, block)-&gt;
  suite = new Suite(title)
  suites.unshift(suite)
  block()
  suites.shift()
</code></pre>

<p>So the global <code>it</code> will always add test to the top of stack, which is the current test suite.</p>

<h2>Hook and run</h2>

<p>For the before/after function, I use the EventEmitter to trigger the hooks, and delegate event to the parent suite:</p>

<pre><code>class Suite extends EventEmitter
  constructor: (@title, @parent)-&gt;
    ...
    @delegate ['before', 'after']
    @on 'result', @reportResult
    @on 'end', @reportSummary

  delegate: (events)-&gt;
    events.forEach (event)=&gt;
      @on event, =&gt; @parent?.emit event

  run: -&gt;
    @emit 'start'
    @tests.forEach (test)-&gt;
      try
        @emit 'before'
        test.fn()
        @emit 'result', test
        @emit 'after'
      catch err
        @emit 'result', test, err
    @emit 'end'
</code></pre>

<h2>Async</h2>

<p>For testing the async callback, <code>it</code> also provide a done callback for the async function.
And I use <a href="https://github.com/caolan/async">async</a> module to handle the test execution sequence.
It will detect the function param, if there is a specific callback param in function, execute in async mode.</p>

<h2>Source</h2>

<p><div><script src='https://gist.github.com/4033566.js?file=minispec.coffee'></script>
<noscript><pre><code>{EventEmitter} = require &#39;events&#39;
async = require &#39;async&#39;

#utils
color = (code)-&gt; (text = &quot;&quot;)-&gt; code + text + &#39;\u001b[0m&#39;
red = color(&#39;\u001b[31m&#39;)
green = color(&#39;\u001b[32m&#39;)
yellow = color(&#39;\u001b[33m&#39;)
pluralize = (count, noun)-&gt; if count &gt; 1 then noun + &#39;s&#39; else noun
indent = (level)-&gt; (&#39;  &#39; for i in [0...level]).join(&#39;&#39;)

class Suite extends EventEmitter
  constructor: (@title, @parent)-&gt;
    @errors = 0
    @tests = []
    @childs = []
    @parent?.childs.push @
    @level = @parent?.level + 1 or 0

    @on &#39;start&#39;, =&gt; @report yellow @title
    @delegate [&#39;before&#39;, &#39;after&#39;] if @parent?
    @on &#39;result&#39;, (test, err)=&gt;
      if err?
        @errors += 1
        @report red &quot;  ✗ #{test.title} (#{err})&quot;
      else
        @report green &quot;  ✓ #{test.title}&quot;
    @on &#39;end&#39;, =&gt;
      count = @tests.length
      errors = @errors

      (reduce = (suites)-&gt;
        suites.forEach (suite)-&gt;
          count += suite.tests.length
          errors += suite.errors
          reduce suite.childs if suite.childs?
      )(@childs)

      console.log yellow &quot;run #{count} #{pluralize(count, &#39;test&#39;) } , #{count - errors} success, #{errors} failed&quot;

  delegate: (events)-&gt;
    events.forEach (event)=&gt;
      @on event, ()=&gt; @parent?.emit event

  report: (text)-&gt; console.log indent(@level) + text

  run: -&gt;
    @emit &#39;start&#39;
    async.forEachSeries @tests, (test, next)=&gt;
      callback = =&gt;
        @emit(&#39;after&#39;)
        @emit(&#39;result&#39;, test)
        next()

      try
        @emit(&#39;before&#39;)
        if test.isAsync
          test.fn callback
        else
          test.fn()
          callback()
      catch err
        @emit(&#39;result&#39;, test, err)
        next()
    , =&gt;
      @childs.forEach (spec)-&gt; spec.run()
      @emit &#39;end&#39; unless @parent?

class Runner
  constructor: (context)-&gt;
    suites = []
    context.it = (desc, fn)-&gt;
      suites[0].tests.push title: desc, fn: fn, isAsync: !!fn.length
    context.before = (fn)-&gt;
      suites[0].on &#39;before&#39;, fn
    context.after = (fn)-&gt;
      suites[0].on &#39;after&#39;, fn
    context.describe = (title, block)-&gt;
      suite = new Suite(title, suites[0])
      suites.unshift(suite)
      block()
      suites.shift()
      suite.run() if suites.length is 0

new Runner(global or window)
</code></pre></noscript></div>
</p>

<h2>Summary</h2>

<p>Credit to VisionMedia&rsquo;s <a href="https://github.com/visionmedia/mocha">mocha</a> framework, lots of solution is comming from there.</p>

<p>But still this is an intersting small project to do in the storm days.</p>

<p>And I am so happy to back to the normal life.</p>
]]></content>
  </entry>
  
</feed>
