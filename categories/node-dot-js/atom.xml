<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: node.js | Neethack]]></title>
  <link href="http://neethack.com/categories/node-dot-js/atom.xml" rel="self"/>
  <link href="http://neethack.com/"/>
  <updated>2013-09-03T01:03:22-04:00</updated>
  <id>http://neethack.com/</id>
  <author>
    <name><![CDATA[Jimmy Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understand event loops]]></title>
    <link href="http://neethack.com/2013/01/understand-event-loops/"/>
    <updated>2013-01-09T18:02:00-05:00</updated>
    <id>http://neethack.com/2013/01/understand-event-loops</id>
    <content type="html"><![CDATA[<p>Event loop is the core feature in node.js,
and is also the reason why it is better on handling requests and realtime communication like long polling.</p>

<h2>The Obstacle of IO</h2>

<p>The reason is on this is because the I/O is expensive:</p>

<!--more-->


<ul>
<li>L1/cache: 3 cycles</li>
<li>L2/cache: 14 cycles</li>
<li>RAM: 250 cycles</li>
<li>Disk: 41,000,000 cycles</li>
<li>Network: 240,000,000 cycles</li>
</ul>


<p>In the case like web application, every request is not computing heavy but require lots of access on database and disk.
So the most time-costing task in a request is waiting database or disk to response.</p>

<p>To solve this problems, the application servers running multiprocess or multithread
to make it able to handle more request at same time.
however, the new process solution will cost large among of memory because the each fork will copy the memory data to new process.
Thread solution is more kindly on memory but still cost more memory.</p>

<h2>What is event loops?</h2>

<p>So the event loops become the solution of this.</p>

<h3>Asynchronous I/O aka Evented I/O</h3>

<p>The problem of I/O obstacle, is because I/O can run concurrently, but your code is not,
So while the code is accessing the I/O, the process can only idle and wait for the response:</p>

<p>Sync I/O in node.js:</p>

<pre><code>fs = require('fs')

var data = fs.readFileSync('file.txt')
// wait for IO to return content
console.log(data)
</code></pre>

<p>But with event loop, the program don&rsquo;t need to wait for the I/O but can handle next task directly.</p>

<pre><code>fs = require('fs')

fs.readFile('file.txt', function(err, data){
  // Called when data is ready
  console.log(data)
});
// returns
</code></pre>

<p>The node.js event loop is using <a href="https://github.com/joyent/libuv">libuv</a> to handle the I/O multiplex
in the core function of libuv:</p>

<pre><code>//src/unix/core.c
int uv_run2(uv_loop_t* loop, uv_run_mode mode) {
  int r;

  if (!uv__loop_alive(loop))
    return 0;

  do {
    uv__update_time(loop);
    uv__run_timers(loop);
    uv__run_idle(loop);
    uv__run_prepare(loop);
    uv__run_pending(loop);
    uv__io_poll(loop, (mode &amp; UV_RUN_NOWAIT ? 0 : uv_backend_timeout(loop)));
    uv__run_check(loop);
    uv__run_closing_handles(loop);
    r = uv__loop_alive(loop);
  } while (r &amp;&amp; !(mode &amp; (UV_RUN_ONCE | UV_RUN_NOWAIT)));

  return r;
}
</code></pre>

<p>We can know the event loop is just a while loop, what it do is keep polling I/O for avalible fd(<a href="http://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>)
and trigger event callback while the fd is ready.</p>

<p>in unix, there&rsquo;s multiple way to polling fd:</p>

<ul>
<li>select</li>
<li>poll</li>
<li>epoll (linux)</li>
<li>kqueue (BSD, unix, osx)</li>
</ul>


<p>node.js is using kqueue on mac os/unix.</p>

<h2>Reactor pattern</h2>

<p><img src="https://www.evernote.com/shard/s77/sh/f0e52914-41be-436a-a278-a8b947e10136/531945eba0426e888dc1eccc6d66156b/res/57054967-d0d3-421d-9c77-fc29957048be/skitch.png" alt="Reactor Pattern" /></p>

<p>In javascript, function can be passed as first class object,
so the code on node.js is heavily using callback and event to make efficient async I/O.</p>

<p>example a db query:</p>

<pre><code>db.posts.find(function(err, posts){
  console.log(posts);
});
</code></pre>

<p>could pass a function as callback to event loop, trigger it when the data is available.
and process can handle other tasks during response.</p>

<p>Also, the process.nextTick can also pass function to event loop, execute the function when the process is avaliable for task.</p>

<pre><code>//Blocked:

// some time consuming task
for(var i=0;i &lt; 10000000000; i++){}
console.log('done');

console.log('return')
//&gt;&gt; done
//&gt;&gt; return
</code></pre>

<p>&ndash;</p>

<pre><code>//Async:

process.nextTick(function(){
  // some time consuming task
  for(var i=0;i &lt; 10000000000; i++){}
  console.log('done');
});

console.log('return')
//&gt;&gt; return
//&gt;&gt; done
</code></pre>

<h2>reference</h2>

<ul>
<li><a href="http://truthabouteventloops.com/">The truth about event loops online masterclass</a></li>
<li><a href="http://howtonode.org/61f361ddb1696aee4afedaf356430cdd768b1d73/understanding-process-next-tick">Understanding process.nextTick()</a></li>
<li><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/">Understanding the node.js event loop</a></li>
<li><a href="http://fred-zone.blogspot.com/2012/09/glib-main-event-loop-nodejs-libuv.html">Integration of GLib Main Event Loop and Node.js (chinese) </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing Papercut]]></title>
    <link href="http://neethack.com/2012/12/announcing-papercut/"/>
    <updated>2012-12-21T00:55:00-05:00</updated>
    <id>http://neethack.com/2012/12/announcing-papercut</id>
    <content type="html"><![CDATA[<p>Inspiring by <a href="https://github.com/jnicklas/carrierwave">carrierwave</a> on Rails.
I wrote a image processing framework to handle images with different versions on node.js and express.
Integrate with node-imagemagick and can upload image to Amazon S3.
It is just a simple version of carrierwave with similiar Api.
But I am comfortable with the features, which is enough for my requirement right now.
I will try to improve the image processing efficiency, and add more processing options for future usage.</p>

<p>You can check this project on <a href="https://github.com/Rafe/papercut">Github</a></p>
]]></content>
  </entry>
  
</feed>
